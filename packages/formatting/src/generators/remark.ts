/**
 * Remark configuration generator
 */

import { stringify as stringifyYaml } from 'yaml';
import { generate as generateRemarkConfig } from '@outfitter/remark-config';
import type { PresetConfig, GeneratedConfig, FormatterDetectionResult } from '../types/index.js';
import type { Result } from '@outfitter/contracts';
import { success, failure, makeError } from '@outfitter/contracts';
import { mergeRawConfig, type YamlPreset } from '../utils/yaml-presets.js';
import { detectCodeBlockRouting } from './remark-advanced.js';

/**
 * Map formatting preset to remark preset
 */
function mapPresetToRemarkPreset(preset: PresetConfig['name']): 'standard' | 'strict' | 'relaxed' {
  return preset; // Direct mapping for now
}

/**
 * Generate Remark configuration file
 */
export function generateRemarkConfigFile(
  preset: PresetConfig,
  yamlPreset?: YamlPreset,
  detection?: FormatterDetectionResult,
): Result<GeneratedConfig, Error> {
  try {
    // Map preset to remark preset name
    const remarkPresetName = mapPresetToRemarkPreset(preset.name);
    const config = generateRemarkConfig({ preset: remarkPresetName });

    // Add code block formatting if appropriate formatters are available
    if (detection) {
      const routing = detectCodeBlockRouting(detection);
      if (routing && Object.keys(routing).length > 0) {
        // Only include languages where the formatter is actually available
        const availableRouting: Record<string, string> = {};
        const { available } = detection;
        
        for (const [lang, formatter] of Object.entries(routing)) {
          if (formatter === 'biome' && available.includes('biome')) {
            availableRouting[lang] = formatter;
          } else if (formatter === 'prettier' && available.includes('prettier')) {
            availableRouting[lang] = formatter;
          }
        }
        
        if (Object.keys(availableRouting).length > 0) {
          config.plugins = config.plugins || [];
          config.plugins.push([
            '@outfitter/formatting/remark-plugins/format-code-blocks',
            { 
              routing: availableRouting,
              preserveIndentation: true,
              verbose: false 
            }
          ]);
        }
      }
    }

    // Apply raw overrides from YAML preset if available
    if (yamlPreset?.raw?.remark) {
      // For remark, we need to handle plugins array specially
      const rawConfig = yamlPreset.raw.remark as {
        plugins?: Array<unknown>;
        settings?: Record<string, unknown>;
      };
      if (rawConfig.plugins) {
        config.plugins = [...(config.plugins || []), ...(rawConfig.plugins || [])];
      }
      if (rawConfig.settings) {
        config.settings = mergeRawConfig(config.settings || {}, rawConfig.settings) as Record<
          string,
          unknown
        >;
      }
    }

    // Generate YAML configuration
    const yamlConfig = {
      plugins: config.plugins,
      settings: config.settings,
    };

    const content = `# Generated by @outfitter/formatting\n# Tool: remark\n# Preset: ${preset.name}\n\n${stringifyYaml(yamlConfig)}`;

    return success({
      path: '.remarkrc.yaml',
      content,
      formatter: 'remark',
      generated: true,
    });
  } catch (error) {
    return failure(
      makeError('INTERNAL_ERROR', 'Failed to generate Remark configuration', { cause: error }),
    );
  }
}

/**
 * Get Remark-specific package.json scripts
 */
export function getRemarkScripts(): Record<string, string> {
  return {
    'format:markdown': 'remark . --output',
    'format:markdown:check': 'remark . --frail',
  };
}
